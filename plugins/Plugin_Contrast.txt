#include "pch.h"
#include "PluginBase.h"
#include <omp.h>


// Простые интерфейсные функции Реализация

DLLEXPORT const char* PluginFunctions()
{
	return "Contrast_Correction Message1 Message2";
}

DLLEXPORT const char* PluginDescriptions(char* str)
{
	if (strcmp(str, "Contrast_Correction") == 0) return "Contrast correction in YUV mode";
	if (strcmp(str, "Message1") == 0) return "some sample message v1";
	if (strcmp(str, "Message2") == 0) return "some sample message v2";
	return "Not found";
}

DLLEXPORT const char* PluginCFG(char* str)
{
	if (strcmp(str, "Contrast_Correction") == 0) return "Label;L1;10;10;Contrast coefficient!TrackBar;INPUT_1;10;30;150;0;500;100;0;100!Label;LBINPUT_1;170;40;1!1";
	if (strcmp(str, "Message1") == 0) return "";
	if (strcmp(str, "Message2") == 0) return "";
	return "Label;L1;10;10;Not found!0";
}

DLLEXPORT const char* GetPluginType(char* str)
{
	if (strcmp(str, "Contrast_Correction") == 0) return "IMG2IMG";  // будет как список
	if (strcmp(str, "Message1") == 0) return "MSGBox";  // бедет встраиваться в меню
	if (strcmp(str, "Message2") == 0) return "MSGBox";  // бедет встраиваться в меню
	return "Not found";
}

DLLEXPORT const char* PluginLabName(char* str)
{
	if (strcmp(str, "Contrast_Correction") == 0) return "Коррекция контраста";
	if (strcmp(str, "Message1") == 0) return "Тестовое сообщение А";
	if (strcmp(str, "Message2") == 0) return "Тестовое сообщение Б";
	return "Not found";
}

/// Перечень экспортируемых функций
DLLEXPORT double Contrast_Correction(unsigned char* InIMG, unsigned char* OutIMG, const int Width, const int Heigth, char* str);
DLLEXPORT const char* Message1();
DLLEXPORT const char* Message2();


// Непосредственное реализация методов

const char* Message1()
{
	return "тестовое сообщение как пример из файла 2";
}

const char* Message2()
{
	return "Второе тестовое сообщение как пример из файла 2";
}


double Contrast_Correction(unsigned char* InIMG, unsigned char* OutIMG, const int Width, const int Heigth, char* str)
{
	double BLUT[256];
	double contr = 1;
	double time_s = omp_get_wtime();
	int mode = 1;
	sscanf_s(str, "%lf", &contr);

	for (int i = 0; i < 256; i++)
	{
		BLUT[i] = (i - 127) * contr + 127;
	}

	unsigned char r, g, b;
	double Yy, u, v;
	int rowSize = Width * 3;
	int stride = rowSize;
	if (stride % 4 != 0)
	{
		stride = rowSize + (4 - stride % 4);
	}

	for (int dy = 0; dy < Heigth; dy++)
	{
		int y = dy * stride;
		for (int kx = 0; kx < Width; kx++)
		{
			int pos = kx * 3 + y;
			b = InIMG[pos];
			g = InIMG[pos + 1];
			r = InIMG[pos + 2];
			RGBToYUV(r, g, b, Yy, u, v);
			Yy = BLUT[int(Yy)];
			YUVToRGB(Yy, u, v, r, g, b);
			OutIMG[pos] = b;
			OutIMG[pos + 1] = g;
			OutIMG[pos + 2] = r;
		}
	}

	return  omp_get_wtime() - time_s;
}